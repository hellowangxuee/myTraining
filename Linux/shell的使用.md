----------------------
### 命令行结构  
shell 是对用户提出的运行程序的请求进行解释的程序。  
shell 分析命令时，认为 | 的优先级高于 ；  
tee 命令将通过管道的数据流截获并放进某个文件，他不是shell的一部分，用途之一是将中间结果保存到一个文件中去  
另一个命令结束符 & ，他与换行符或者分号的功能基本一致，但他可以告诉 shell 不必等待命令结束  
$ long-running-command &    //长时间运行的进程 id  
$ sleep 5       //5秒之后出现提示符  
$ & 表示命令的终止  
$ echo hello >junk  
$ >junk echo hello       //两条命令是一样的效果，先运行带一个参数的echo ， 再把输出放入文件junk 中。
### 元字符
|元字符|说明|
|----|-----
|>|prog>file 将标准输出定向到file
|>>|prog>>file 将标准输出附加到file
|<|prog< file 从文件中获取标准输出
|||p1 | p2 将p1的标准输出作为p2的标准输入
|<< str|here document:标准输入从here document读入，知道出现下一个str
| * |匹配文件名中的零个或多个字符
|?|匹配文件名中任意单个字符
|{CCC}|匹配文件名中CCC范围内的任意字符，如0~9或a~z都是合法的
|;|命令结束符：p1;p2运行p1，再运行p2
|&|与;类似，但不等p1结束
|'...'|运行...中的命令，输出结果代替'...'
|(...)|在子shell 里运行...的命令
|{...}|在当前shell 运行...中的命令（很少使用）
|$1、$2等|$0......$9可代表shell 文件的参数
|$var|shell 变量var 的值
|${var}|变量var的值
|\\|\c将字符c作为文字，但\后面的加换行符无效
|'...'|...表示文字
|"..."|在...中的$、'...'和\得到解释后，将...作为文本文字
|#|表示注释的开始
|Var=值|为变量var赋值
|p1&&p2|运行p1;若成功，再运行p2
|p1\|\|p2|运行p1；若不成功，再运行p2
如果不想使用元字符的特殊功能，可以有几种方法来表示他们。防止他们被shell 解释  
$ echo '\*\*\*'  
\*\*\*  
也可以使用双引号"..."，但是 shell 会在双引号中寻找 $，"..."以及\，因此如果用户不想处理双引号中的字符串，就不要使用双引号。  
$ echo \\\*\\\*\\\*  
一种引号可以保护另一种引号：  
$ echo "Don't do that!"  
Don't do that!  
引号不必包含整个参数：  
$ echo x'\*'y  
x\*y  
$ echo '\*'A'?'  
\*A?  
$ echo abc\\  
\> def\\  
\> ghi  
abcdefghi  
行末尾加入\可以表示该行未完，避免 shell 中单行输入过长  
### 创建新命令
如果一个命令序列要被反复执行多次，那么最好把他组织成一个新命令，这样就可以像使用常规命令那样执行它。  
例：  
用管道线命令统计用户数量：  
$ who | wc -l  
要实现它，可以创建一个名为 nu 的新程序来完成这件工作。  
$ echo 'who | wc -l' >nu  
shell 和编辑器、who 或 wc 一样，也是一个程序，名字为 sh 。 
